//Inverting trees is swaping of left and right nodes, for this we can use recursive method(we used mostly), iterative method that includes queues, 

//For balanced trees, we can use the recusive method, For skwed trees we use iterative, which stops the stack overflow...

#include<bits/stdc++.h>
using namespace std;
struct Node{
    int data;
    Node* left;
    Node* right;
    Node(int data){
        this->data = data;
        this->left = nullptr;
        this->right = nullptr;
    }
};

//recursive.
Node* r_invertTree(Node* root){
    if(root == nullptr) return root;
    
    swap(root->left, root->right);
    r_invertTree(root->left);
    r_invertTree(root->right);
    
    return root;
}

//iterative..
Node* i_invertTree(Node* root){
    if(root == nullptr) return nullptr;
    
    queue<Node*> q;
    q.push(root);
    
    while(!q.empty()){
        Node* current = q.front();
        q.pop();
        
        swap(current->left,current->right);
        
        if(current->left!=nullptr) q.push(current->left);
        if(current->left!=nullptr) q.push(current->right);
    }
    
    return root;
}


int main(){
    cout<<"Inverting the tree"<<endl;
    Node* root = new Node(1);
    root->left = new Node(2);
    root->right = new Node(3);
    
    // Invert using recursive
    root = r_invertTree(root);

    // OR invert using iterative
    // root = i_invertTree(root);

    cout << "Tree inverted successfully\n";
}
